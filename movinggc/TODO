This file is part of GNU epsilon.

Copyright (C) 2015 Luca Saiu

GNU epsilon is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

GNU epsilon is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU epsilon.  If not, see <http://www.gnu.org/licenses/>.


Implement or at least document my circular-buffer write barrier idea.
It has the potential of being extremely fast, at the cost of one
reserved register and three instructions per write barrier: increment,
mask or remainder, store (no conditionals); one more instruction on
RISCs if the buffer size is too large for the mask to fit in an
immediate operand.  On the x86 it might even be possible to avoid the
masking operation using a sub-register.  I can reliably detect
overflow by checking if the last buffer element (the only one I need
to initialize) is non-zero.

Previous work by others: "The Design and Implementation of the SELF
Compiler, and Optimizing Compiler for Object-Oriented Programming
Languages", Chambers 1992 (cited by "A Fast Write Barrier for
Generational Garbage Collectors", Hölzle 1993", p.2) shows another
three-instruction write barrier (on the SPARC), again with no
conditionals, using card marking.  Hölzle reduces it to two
instructions, possibly losing some precision.  Hölzle finds his
technique to have superior performance to SSBs (for SELF, a
high-mutation language).
My technique is more precise than either in the common case, but has
bad performance in the worst case.  [Hosking 1992] introduced the
"Sequential Store Buffer" (with or without filtering) similar to what
I've just independently rediscovered.  Instead of my modulo idea
Hosking used a hardware trap to detect buffer overflow.
Add a GC check point function, which is trivial by itself.  Start
thinking of how to support blocking primitives in multi-thread
programs.

Use the write barrier in epsilon primitives.  Add an initializing
store primitive if it's not already there.

Store older->younger inter-generational pointers in only one place (in
the older generation), not in every in-between generation.  make sure
noting breaks when G3 points to G1, then G1 objects are promoted to
G2.

Make the header size a configuration parameter.  This will be very
useful for instrumenting the code, and should not complicate the
source too much.

The idea of tagging pointers with a 1 bit and non-pointers with a 0
bit was hinted at by Appel in, ironically, "Runtime Tags Aren't
Necessary", 1988.  Appel stated that "Some implementations use a
low-order tag of 0 for integers", correctly hinting at the advantages;
however he gave no examples of any such implemenations.  I would like
to know them.

A pre-GC hook should directly call a function on each root, scavenging
it.  Do away with the post-GC hook as well.  Dynamic roots are still
useful for C primitives.

The code generated for the fast path of movinggc_allocate_chars is
obviously subotimal, and I've not been able to convince GCC to assume
word-aligned pointers using __builtin_assume_aligned.  This may or may
not be a big deal: I mean to write an assembly version of that for the
architectures I support.  However the idea of using char* pointers and
allocation sizes in bytes introduces some complexity.  I still think I
can gain something from that; if not the code should be simplified.

Use movinggc_fromspace_next_unallocated_object_field instead of
movinggc_fromspace_next_unallocated_word.  "Pre-allocating the
header" will save or simplify a few instructions in the allocation
fast path.

Allocation statistics are likely inaccurate.  I should only count the
memory actually allocated by the mutator, including headers but
excluding what I do internally to resize semispaces.

Design a sensible strategy for growing and shrinking semispaces.

Do away with "administrative" collections for resizing semispaces.
When growing I should resize only the new tospace after a GC; at the
next collection the fromspace will be replaced as well.  When
shrinking I should make the "nominal" size of the new fromspace go
down, and immediately resize the new tospace; at the next collection
I'll adjust the other semispace to match.

Provide a way of saving and restoring global register variables,
for interoperation with other C code.

Dynamic roots: add underflow checking when debugging.

Why such a variance in runtime?  [FIXME: is this still true?]

Shrink semispaces as well (optionally only up to a minimal size): it's
worth to keep semispaces always fitting in L2, if not in L1.  It's
debatable whether it pays to have them as small as possible, trading
better locality for increased collection frequency.
