This file is part of GNU epsilon.

Copyright (C) 2015 Luca Saiu

GNU epsilon is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

GNU epsilon is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU epsilon.  If not, see <http://www.gnu.org/licenses/>.

Remove movinggc_tospace.  It shouldn't be a global.  Possibly do the
same for movinggc_fromspace.

Write barrier!

The idea of tagging pointers with a 1 bit and non-pointers with a 0
bit was hinted at by Appel in, ironically, "Runtime Tags Aren't
Necessary", 1988.  Appel stated that "Some implementations use a
low-order tag of 0 for integers", correctly hinting at the advantages;
however he gave no examples of any such implemenations.  I would like
to know them.

A pre-GC hook should directly call a function on each root, scavenging
it.  Do away with the post-GC hook as well.  Dynamic roots are still
useful for C primitives.

The code generated for the fast path of movinggc_allocate_chars is
obviously subotimal, and I've not been able to convince GCC to assume
word-aligned pointers using __builtin_assume_aligned.  This may or may
not be a big deal: I mean to write an assembly version of that for the
architectures I support.  However the idea of using char* pointers and
allocation sizes in bytes introduces some complexity.  I still think I
can gain something from that; if not the code should be simplified.

Use movinggc_fromspace_next_unallocated_object_field instead of
movinggc_fromspace_next_unallocated_word.  "Pre-allocating the
header" will save or simplify a few instructions in the allocation
fast path.

Allocation statistics are likely inaccurate.  I should only count the
memory actually allocated by the mutator, including headers but
excluding what I do internally to resize semispaces.

Design a sensible strategy for growing and shrinking semispaces.

Do away with "administrative" collections for resizing semispaces.
When growing I should resize only the new tospace after a GC; at the
next collection the fromspace will be replaced as well.  When
shrinking I should make the "nominal" size of the new fromspace go
down, and immediately resize the new tospace; at the next collection
I'll adjust the other semispace to match.

Provide a way of saving and restoring global register variables,
for interoperation with other C code.

Dynamic roots: add underflow checking when debugging.

Why such a variance in runtime?  [FIXME: is this still true?]

Shrink semispaces as well (optionally only up to a minimal size): it's
worth to keep semispaces always fitting in L2, if not in L1.  It's
debatable whether it pays to have them as small as possible, trading
better locality for increased collection frequency.
