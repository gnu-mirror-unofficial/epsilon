#!/bin/bash

## This file is part of GNU epsilon
## Copyright (C) 2012 Universit√© Paris 13

## Written by Luca Saiu

## This file is part of GNU epsilon.

## GNU epsilon is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## GNU epsilon is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with GNU epsilon.  If not, see <http://www.gnu.org/licenses/>.


# Go to the toplevel source directory:
cd `dirname $0`/..

# Supported parameter types:
types='c s i l w f d'

# Maximum parameter no for a callable C function:
maximumparameterno=2

# Other prototypes, with more paramter than $maximumparameterno, which we want
# to support.  Of course they are written in our abbreviated notation, for example
# w_wcwf to mean word (word, char, word, float)
otherprototypes='w_wwww'

generate_c_instruction ()
{
    parameterno=$1; shift
    r=$1; shift
    p1=$1; shift
    p2=$1; shift
    p3=$1; shift
    p4=$1; shift
    printf 'INSTRUCTION(svm_callc_'$r'_'$p1$p2$p3$p4', {'
    case $r in
        ( f | d ) printf 'C_FRESULT = (svm_float)(';;
        ( v ) printf '(';;
        ( c ) printf 'C_RESULT = EPSILON_CHAR_TO_EPSILON_WORD(';;
        ( s ) printf 'C_RESULT = EPSILON_SHORT_TO_EPSILON_WORD(';;
        ( i ) printf 'C_RESULT = EPSILON_INT_TO_EPSILON_WORD(';;
        ( l ) printf 'C_RESULT = EPSILON_LONG_TO_EPSILON_WORD(';;
        ( w ) printf 'C_RESULT = (';;
        ( * ) printf 'Unexpected case\n'; exit -1;;
    esac
    printf 'EPSILON_CALL_C%i(' $parameterno
    for t in $r $p1 $p2 $p3 $p4; do
        if test "$t" != ''; then
            printf "$t, "
        fi
    done
    printf 'IMMEDIATE'
    nonfloatindex=0
    floatindex=0
    for t in $p1 $p2 $p3 $p4; do
        case $t in
            ( f ) printf ', (float)C_FPARAMETER(%i)' $floatindex
                  floatindex=$(( $floatindex + 1 ));;
            ( d ) printf ', (double)C_FPARAMETER(%i)' $floatindex
                  floatindex=$(( $floatindex + 1 ));;
            ( c ) printf ', EPSILON_WORD_TO_CHAR(C_PARAMETER(%i))' $nonfloatindex
                  nonfloatindex=$(( $nonfloatindex + 1 ));;
            ( s ) printf ', EPSILON_WORD_TO_SHORT(C_PARAMETER(%i))' $nonfloatindex
                  nonfloatindex=$(( $nonfloatindex + 1 ));;
            ( i ) printf ', EPSILON_WORD_TO_INT(C_PARAMETER(%i))' $nonfloatindex
                  nonfloatindex=$(( $nonfloatindex + 1 ));;
            ( l ) printf ', EPSILON_WORD_TO_LONG(C_PARAMETER(%i))' $nonfloatindex
                  nonfloatindex=$(( $nonfloatindex + 1 ));;
            ( w ) printf ', C_PARAMETER(%i)' $nonfloatindex
                  nonfloatindex=$(( $nonfloatindex + 1 ));;
            ( * ) printf 'Unexpected case\n'; exit -1;;
        esac
    done
    printf '));});\n'
}

generate_flex_rule ()
{
    r=$1; shift
    ps=$1; shift
    printf '"callc-%s-%s"  { return CALLC_%s_%s; }\n' "$r" "$ps" "$r" "$ps"
}

generate_bison_token ()
{
    r=$1; shift
    ps=$1; shift
    printf '%%token CALLC_%s_%s\n' "$r" "$ps"
}

generate_bison_rule ()
{
    r=$1; shift
    ps=$1; shift
    printf '| CALLC_%s_%s immediate { $$ = svm_make_unresolved_instruction_i(svm_callc_%s_%s, $2); }\n' \
        "$r" "$ps" "$r" "$ps"
}

generate ()
{
    parameterno=$1; shift
    r=$1; shift
    p1=$1; shift
    p2=$1; shift
    p3=$1; shift
    p4=$1; shift
    if test "$pass" = 1; then
        echo 'svm_callc_'$r'_'$p1$p2$p3$p4',' >> svm/c-instructions.h
        generate_c_instruction "$parameterno" "$r" "$p1" "$p2" "$p3" "$p4" >> svm/c-instructions.c
        generate_flex_rule "$r" "$p1$p2$p3$p4" >> svm/scanner.l
        generate_bison_token "$r" "$p1$p2$p3$p4" >> svm/parser.y
    else
        generate_bison_rule "$r" "$p1$p2$p3$p4" >> svm/parser.y
    fi
}

cat_before ()
{
    delimiter=$1; shift
    awk 'BEGIN{found=0}/^'$delimiter'$/{found=1}{if(!found)print}'
}

cat_after ()
{
    delimiter=$1; shift
    awk 'BEGIN{found=0}{if(found)print}/^'$delimiter'$/{found=1}'
}

# Clear the target files which are completely generated by this script, without templates:
rm -f svm/c-instructions.c svm/c-instructions.h svm/parser.y svm/scanner.l

# Generate the scanner and parser first part:
cat_before 'CALL-INSTRUCTION-RULES' < svm/scanner.l-template > svm/scanner.l
cat_before 'CALL-INSTRUCTION-TOKENS' < svm/parser.y-template > svm/parser.y

for pass in 1 2; do
    if test "$pass" = 2; then
        # Generate the intermediate part of the parser:
        cat_after 'CALL-INSTRUCTION-TOKENS' < svm/parser.y-template | \
            cat_before 'CALL-INSTRUCTION-RULES' >> svm/parser.y
    fi
    
    for r in 'v' $types; do
        generate 0 $r
    done
    if test "$maximumparameterno" -ge 1; then
        for r in 'v' $types; do
            for p1 in $types; do
                generate 1 $r $p1
            done
        done
    fi
    if test "$maximumparameterno" -ge 2; then
        for r in 'v' $types; do
            for p1 in $types; do
                for p2 in $types; do
                    generate 2 $r $p1 $p2
                done
            done
        done
    fi
    if test "$maximumparameterno" -ge 3; then
        for r in 'v' $types; do
            for p1 in $types; do
                for p2 in $types; do
                    for p3 in $types; do
                        generate 3 $r $p1 $p2 $p3
                    done
                done
            done
        done
    fi
    if test "$maximumparameterno" -ge 4; then
        for r in 'v' $types; do
            for p1 in $types; do
                for p2 in $types; do
                    for p3 in $types; do
                        for p4 in $types; do
                            generate 4 $r $p1 $p2 $p3 $p4
                        done
                    done
                done
            done
        done
    fi
    for p in $otherprototypes; do
        parameterno=$(( `echo $p | wc -c` - 3 )) # return type, _, newline
        echo "The other prototype $p has $parameterno parameters"
        separate_type_arguments=`echo $p | sed 's/_//g' | sed 's/\(.\)/ \1/g'`
        echo "The other prototype $p corresponds to the separate type arguments $separate_type_arguments"
        generate "$parameterno" $separate_type_arguments
#        sed 's/\(.\)/Q\1/g'
    done
done

# Generate the final part of the scanner and parser:
cat_after 'CALL-INSTRUCTION-RULES' < svm/scanner.l-template >> svm/scanner.l
cat_after 'CALL-INSTRUCTION-RULES' < svm/parser.y-template >> svm/parser.y
